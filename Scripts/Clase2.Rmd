---
title: "Curso básico R studio"
author: "Stephanie Hereira Pacheco"
output:
  pdf_document:
    toc: true
    toc_depth: 2
  html_document: default
editor_options: 
  markdown: 
    wrap: sentence
---

```{r, include=FALSE, eval=FALSE}
if(knitr::is_html_output()){
  knitr::opts_chunk$set(out.width = "500px",
                        out.extra='style="display: block; margin-left: auto; margin-right: auto; background-color: #000; padding:3px;"')
} else{
  knitr::opts_chunk$set(out.width = "4in")
}
```

# *Data frames*

La forma más común de almacenar un set de datos en R es usando un *data frame*.
Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas.
Podemos entender a los data frames como una versión más flexible de una matriz.
Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo.

Vamos a trabajar con una data de ejemplo y exploraremos esta *data frame*, es una data en la que evaluan el efecto de la dosis de vitamina C sobre el crecimiento de los dientes de unos tipos de cerdos.
La función `str` es útil para obtener más información sobre la estructura de un objeto:

```{r, echo=TRUE}
data(ToothGrowth)
str(ToothGrowth)
```

Esto nos dice mucho más sobre el objeto.
Vemos que la tabla tiene 60 filas y 3 variables.
Podemos mostrar las primeras seis líneas usando la función `head`:

```{r}
head(ToothGrowth)
```

Para crear un data frame usamos la función *data.frame()*.
Esta función nos pedirá un número de vectores igual al número de columnas que deseemos.
Todos los vectores que proporcionemos deben tener el mismo largo.
Es decir, un data frame está compuesto por vectores.
Veamos un ejemplo:

```{r}
df <- data.frame(
  "entero" = 1:3, 
  "factor" = c("alto", "medio", "bajo"), 
  "letras" = as.character(c("a", "b", "c"))
)

df
dim(df)
```

La función `dim` nos permite conocer también las dimensiones de nuestra data frame.
En este caso tenemos 3 filas y 3 columnas.
Las funciones `names` y `colnames` nos permiten conocer los nombres de los headers o de las columnas.

```{r}
names(df)
colnames(df)
```

## El operador `$` y otras formas de acceso

Para tener acceso a las diversas variables o columnas de un *data.frame* utilizamos el operador de acceso `$`, por ejemplo, si quisieramos tener acceso a la variable 'factor' de la *data.frame* **df** de la siguiente manera:

```{r}
df$factor
class(df$factor)
is.vector(df$factor)
```

Cuando usamos el operador `$` el tipo de objeto que obtenemos es un vector, en el ejemplo como la columna 'factor' es una cadena de caracteres entonces al usar las funciones *class()* y *is.vector()* nos confirma lo antes mencionado.

**Tip**: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres.
Escriban `df$f` y luego presionen la tecla *tab* en su teclado.
Esta funcionalidad y muchas otras características útiles de autocompletar están disponibles en RStudio, esto aplica también para las funciones.

En el caso de las listas también podemos acceder con el operador `$`, aunque también podemos usar corchetes dobles (`[[`) así.
Por ejemplo declaramos una lista:

```{r}
notas_estudiantes <- list(nombres = c("Ana", "Clara", "Sofy"),
               id_estudiante = c("i1", "i2", "i3"),
               notas = c(10, 9,7))
```

Y queremos extraer los nombres de los estudiantes, entonces hacemos\_

```{r}
notas_estudiantes$nombres
notas_estudiantes[["nombres"]]
```

Y obtenemos el mismo resultados.

Para el caso de las matrices se puede acceder usando corchetes (`[`).
Si desean la primera fila y la pimera columna, entonces:

```{r}
mat<- matrix(1:10, ncol = 2, nrow = 5)
mat[1,1]
mat
```

Para acceder solo a la primera fila y solo a la primera columa usamos las comas, así: s

```{r}
mat[1, ] #acceder primera fila
mat[, 1] #acceder a la primera columna
is.vector(mat[, 1])
```

Notese que esto devuelve un vector, no una matriz.

Del mismo modo, si desean la segunda columna completa, dejen el lugar de la fila vacío:

```{r}
mat[, 2]
```

Esto también es un vector, no una matriz.
Lo corroboramos con la función *is.vector()*

Se pueden crear subconjuntos basados tanto en las filas como en las columnas:

```{r}
mat[2:4 , 1:2]  #en orden de posición es filas primero y luego columnas
```

Podemos convertir las matrices en *data frames* usando la función `as.data.frame`:

```{r}
as.data.frame(mat)
```

## Creando subconjuntos.

En R, podemos obtener subconjuntos de nuestras estructuras de datos.
Es decir, podemos extraer partes de una estructura de datos (nuestro conjunto).

También podemos usar corchetes individuales (`[`) para acceder a las filas y las columnas de un *data frame* y es exactamente igual que lo que se aplicó con las matrices.
A esto es lo que llamamos **Subconjuntos** de los *data.frame*.
Como las listas de datos que usamos para *notas_estudiantes* tienen las mismas dimensiones entonces podemos coercionarlo a ser una *data.frame*:

```{r}
evaluaciones<- as.data.frame(notas_estudiantes)
```

Y para obtener más de una entrada se puede utilizar un vector de entradas múltiples como índice:

```{r}
evaluaciones[c(1,2)]
```

Obtenemos las dos primeras columnas.
Las secuencias definidas anteriormente son particularmente útiles si necesitamos acceso, digamos, a los dos primeros elementos:

```{r}
evaluaciones[1:2]
```

Ahora bien, si queremos **NO** elegir por ejemplo la primera columna o dejarla por fuera, entonces usamos el signo **'-'**:

```{r}
evaluaciones[,-1]
```

Si los elementos tienen nombres de columna o *headers* también podemos acceder a las entradas utilizando estos nombres:

```{r}
evaluaciones[c("nombres","notas")]
```

Ahora bien, podemos seleccionar datos que tengan características específicas, por ejemplo, todos los valores mayores a cierto número o aquellos que coinciden exactamente con un valor de nuestro interés.
Para realizar esta operación haremos uso de índices y operadores lógicos.

| Operador | Comparación           |
|----------|-----------------------|
| \<       | Menor que             |
| \<=      | Menor o igual que     |
| \>       | Mayor que             |
| \>=      | Mayor o igual que     |
| ==       | Exactamente igual que |
| ! =      | No es igual que       |
| !        | No es                 |
| =        | Igual que             |
| &, \|    | y, ó                  |

Por ejemplo en el caso de la tabla de **evaluaciones**, si queremos escoger los valores que sean mayor de 8 en las notas obtenidas:

```{r}
evaluaciones$notas > 8
```

Observamos cuales cumplen con la condición si muestran `TRUE`.
Ahora para usar este filtro y hacer un subconjunto con el *data.frame*, hacemos:

```{r}
mas_de_8<-evaluaciones[evaluaciones$notas > 8,]
mas_de_8
```

Si queremos usar más de una condición pero indicando negación:

```{r}
evaluaciones[!(evaluaciones$notas > 8 & evaluaciones$nombres == "Clara"), ]

```

Para escoger un valor que sea exactamente igual a una condición usamos '==':

```{r}
evaluaciones[evaluaciones$nombres == "Sofy",]

```

# Importando datos {#importing-data}

```{r, echo=FALSE}
img_path <- "../images/"
```

Para el ejemplo que vimos en el capítulo pasado usamos un dataset que está en el ambiente de R por default, si queremo saber cuales son los datasets que tenemos en nuestro ambiente, podemos usar el comando *data()* y nos desplegará la lista:

```{r}
data()
```

Si queremos utilizar los datos de nuestro trabajo o usar datos de una base de datos o que de una 'dataset' que se encuentre en internet, debemos *Importar* estos datos a nuestra sesión de R.
Usualmente tenemos nuestros datos guardados en hojas de cálculo en diferentes formatos con diferentes extensiones, estos son los más populares:

-   separados con *coma* o *punto y coma* (`,`,`;`): csv,

-   separados con tabulaciones o espacios (*tab,* `\t`) : .txt o .tsv,

-   Hojas de cálculo de excel: .xls, son las más usadas.

A continuación muestro una imagen de como se ven un .csv y .txt:

```{r, echo=FALSE, out.width= "400px", fig.align='center'}
knitr::include_graphics(file.path(img_path,"files.png"))
```

## El directorio de trabajo y rutas

Antes de importar nuestros propios archivos, tablas o datos debemos estar seguros en qué directorio nos encontramos, para estar seguros que vamos a importar el archivo deseado a R.

Existen tres opciones para esto:

1.  Utilizar **getwd()** y **setwd()**, como lo vimos anteriormente, para establecer y saber en qué directorio nos encontramos y si es el caso, cambiarlo.

2.  Poner la ruta completa de nuestro archivo, sin importar donde esté.

3.  Utilizar **"Import Dataset"** de nuestro panel de ambiente y ubicar manualmente la ubicación del archivo.

El reto de la primera opción es permitir que las funciones de importación de R sepan dónde buscar el archivo que contiene los datos.
La forma más sencilla de hacer esto es tener una copia del archivo en la carpeta donde las funciones de importación buscan por defecto, es decir guardar este archivo en nuestro directorio de trabajo.

## Descargando un archivo de la web

Para descargar algún archivo en la web a utilizar, podemos correr el siguiente código:

```{r, eval=TRUE}
download.file(
  url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data", 
  destfile = "iris.data")

```

Si observamos nuestros archivos en nuestro directorio de trabajo con el código *list.files()* veremos que se encuentra esta data que hemos descargado.

El código anterior no lee los datos sólo, en este caso, descarga la data.
Otra forma de descargarlo y a la vez abrirlo es de la siguiente manera, con el paquete *readr*:

```{r, warning=FALSE, message=FALSE}
iris_dat<-readr::read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data")
```

## Funciones de importación

Una vez descargado o que se encuentre en nuestro directorio de trabajo, podemos importar los datos con solo una línea de código.
Aquí usamos la función `read.csv` o `read.delim` de R base (que viene default cuando descargamos R).

```{r, eval=FALSE}
iris_data<- read.csv("iris.data", header = F)
iris_data<- read.delim("iris.data",header = F, sep = ",")
```

Los datos se importan y almacenan en el obejto `iris_dat`.
Los argumentos *header = F* y *sep=","* son parámetros extras que podemos agregar a la función para indicarle algunas cosas.
Por ejemplo *header=F*, le estamos diciendo que la prima fila no contiene los títulos o *headers* de la tabla, en caso de que si fuera así, le daríamos *TRUE*.
Podemos usar la tecla *'tab'* para explorar las demás opciones que podemos utilizar en estas funciones.

También el paquete *readr* tiene otras funciones de importación muy parecidas:

```{r, warning=FALSE, message=FALSE}
library(readr)
iris_data<-read_csv("iris.data", col_names = c("Longitud.sepalo", "Ancho.Sepalo" ,
                                               "Longitud.Petalo" ,"Ancho.Petalo" , "Especies"  ))
```

En esta función usamos el argumento *col_names* para establecer los *Headers* o nombre de las columnas de esta tabla.

La segunda opción que vimos es utilizar la ruta completa del archivo, por ejemplo:

```{r}
data<- read_csv("../Data/penguins_size.csv")
```

\

En este ejemplo, la data que importamos está ubicada en la carpeta de 'Data' de este proyecto.
Y vemos que esta función de *readr* también nos da información del archivo como el tipo de variable y el nombre de las mismas.

La última opción, un poco más fácil para algunos y más interactiva es usar *Import Dataset* del planel del ambiente.

```{r, echo=FALSE, out.width= "500px", fig.align='center'}
knitr::include_graphics(file.path(img_path,"import.png"))

```

En esta opción podemos importar tablas con cualquiera de las funciones que despliega dependiendo del tipo de archivo, yo recomiendo si es .csv o .txt usar *readr* que es el mismo que usa tidyverse, como lo vimos anteriormente.
Paquete que veremos más detalladamente junto con *readxl* en la siguiente sección.

\newpage

## Los paquetes readr y readxl[^1]

[^1]: <https://rafalab.github.io/dslibro/importing-data.html>

### readr

El paquete **readr** un paquete de tiyverse, tiene las siguientes funciones para importar arvhivos con diferentes extensiones:

+------------+---------------------------------------------------------------+----------------+
| Función    | Tipo de archivo                                               | Extensión      |
+============+===============================================================+================+
| read_table | valores separados por espacios en blanco                      | txt            |
+------------+---------------------------------------------------------------+----------------+
| read_csv   | valores separados por comas                                   | csv            |
+------------+---------------------------------------------------------------+----------------+
| read_csv2  | valores separados por punto y coma                            | csv            |
+------------+---------------------------------------------------------------+----------------+
| read_tsv   | valores separados delimitados por tab                         | tsv o txt      |
+------------+---------------------------------------------------------------+----------------+
| read_delim | formato de archivo de texto general, debe definir delimitador | txt, csv o tsv |
+------------+---------------------------------------------------------------+----------------+

### readxl

Este paquete ofrece funciones para leer archivos provienetes de Microsoft Excel:

| Función    | Formato                             | Sufijo típico |
|------------|-------------------------------------|---------------|
| read_excel | detectar automáticamente el formato | xls, xlsx     |
| read_xls   | formato original                    | xls           |
| read_xlsx  | nuevo formato                       | xlsx          |

### Algunos tips para hojas de cálculo de excel...

-   Evitar cosas como tener muchos diferentes formatos (colores, subrayados, etc).
-   Evitar en lo posible celdas vacías y poner un dato en cada celda
-   Evitar celdas con cálculo o aplicación de fórmulas.
-   Tenga en cuenta que nuestros datos que tenemos en hojas de cálculo en excel también podemos guardarlos en otros formatos un poco más fáciles para ser importados como los que ya vimos (.csv y .txt). Esto utilizando la opción *Guardar como* y escogiendo el tipo de formato deseado. En la imagen podemos ver un ejemplo de esto:

```{r, echo=FALSE, out.width= "350px", fig.align='center'}
knitr::include_graphics(file.path(img_path,"saveexcel.jpg"))

```

# Funciones Básicas de R

## `sort` y `order`

Digamos que queremos clasificar las notas de la mayor a la menor, podemos usar alguna de estas dos funciones:

```{r}
sort(evaluaciones$notas)
```

```{r}
order(evaluaciones$notas)
```

## `max` y `which.max`

Si solo estamos interesados en la entrada con el mayor valor, podemos usar `max`:

```{r}
max(evaluaciones$notas)
```

y `which.max` nos dice que valor es el mayor, posicionalmente:

```{r}
which.max(evaluaciones$notas)
```

Para el mínimo, podemos usar `min` y `which.min` del mismo modo.

## `which`

La función `which` nos dice qué entradas de un vector lógico son TRUE.
Entonces podemos escribir:

```{r}
ind <- which(evaluaciones$nombres == "Ana")
ind
evaluaciones[ind,]
```

De esta forma también podemos usarlo para filtrar y hacer subconjuntos.

## `match`

La función `match` nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector:

```{r}
v1<- c("Uvas", "Peras", "Mandarinas", "Plátanos", "Manzanas")
v2<- c("Uvas","Cerezas", "Mandarinas", "Naranjas", "Manzanas") 
match(v1, v2)
match(c("Peras", "Plátanos"), v1)
ind<-match(c("Peras", "Plátanos"), v1)
v1[ind]
```

Este filtro puede aplicarse de igual manera a un *data.frame*:

```{r}
ind2<- match(v1, v2)
frutas<- data.frame(persona1=v1,persona2=v2)
frutas[ind,]
na.omit(frutas[ind2,])     #na.omit() nos permite quitar las celdas que contienen NA's
```

## `%in%`

Si en lugar de un índice queremos un lógico que nos diga si cada elemento de un primer vector está en un segundo vector, podemos usar la función `%in%`.
Siguiendo el ejemplo pasado:

```{r}
c("Peras", "Plátanos") %in% frutas$persona1
```

Nos dice que los dos elementos qu buscamos están presente en el *data.frame()*

**Avanzado**: `match` y `%in%` pueden dar el mismo output usando `which`:

```{r}
match(c("Peras", "Plátanos"), frutas$persona1)
which(frutas$persona1 %in% c("Peras", "Plátanos"))
```

### La familia de funciones `apply`

Esta familia de funciones es usada para aplicar una función a cada elemento de una estructura de datos.
En particular, es usada para aplicar funciones en matrices, data frames, arreglos y listas.
Para entender más fácilmente el uso de la familia apply, recordemos la vectorización de operaciones.
Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos.
La familia apply esta formada por las siguientes funciones:

-   **apply()**

-   **lapply()**

-   **mapply()**

-   **sapply()**

-   eapply()

-   rapply()

-   tapply()

-   vapply()

Es una familia numerosa y esta variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente específicas.
Las más usadas son las que están en negrita, repasaremos la función apply pero no nos detendremos mucho porque muchas de estas no están al alcance del presente curso.

### apply

`apply` aplica una función a todos los elementos de una **matriz**.

La estructura de esta función es la siguiente.

```{r, eval=FALSE}
apply(X, MARGIN, FUN)
```

`apply` tiene tres argumentos:

-   `X`: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame.

-   `MARGIN`: La dimensión (margen) que agrupará los elementos de la matriz `X`, para aplicarles una función.
    Son identificadas con números, **1** son renglones y **2** son colummnas.

-   `FUN`: La función que aplicaremos a la matriz `X` en su dimención `MARGIN`.

Si queremos sumar todas las columnas de una matriz, podemos aplicar esta función, para comparar usaremos también la función `ColSums()` que realiza esta misma operación:

```{r}
matriz<- matrix(1:20, ncol = 5, nrow = 4)
matriz
apply(X = matriz, MARGIN = 2, FUN = sum)
colSums(matriz)
```

También podemos aplicar múltiples funciones a una matriz:

```{r}
multiples.func <- function(x) {
      c(sum = sum(x), prom = mean(x), max = max(x))}
apply(X = matriz, MARGIN = 2, FUN = multiples.func)
```

## Estructuras de control

Estas estructuras nos permiten controlar la manera en que se ejecuta nuestro código.Se establecen como condicionales en nuestros código.
Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función.

Las estructuras de control más usadas son:

| Estructura de control | Descripción      |
|-----------------------|------------------|
| if, else              | Si, de otro modo |
| while                 | mientras         |
| for                   | Para             |
| break                 | interrumpe       |
| next                  | siguiente        |

También las tocaremos pero no profundizaremos mucho en ellas, pero conoceremos como se utilizan.

### If, else

If y else se utilizan para crear condiciones, por ejemplo, si cumple esta condición entonces haz esto, de otra manera, haz esto.

Ejemplo:

```{r}
if(10>2) {"Verdadero"
} else {
  "Falso"
}

```

```{r}
if(10<2) {"Verdadero"
} else {
  "Falso"
}
```

También hay una función que reune estas dos condiciones, es`ifelse()` y se usa de igual manera:

```{r}
ifelse((10>2), "Verdadero", "Falso")

```

Podemos aplicarlo en los *data.frames* usando como ejemplo el dataset anterior:

```{r}
ifelse(evaluaciones$notas>7,  "Aprobado", "Reprobado")

```

### for

La estructura `for` nos permite ejecutar un bucle (*loop*), realizando una operación para cada elemento de un conjunto de datos.

Ejemplo:

```{r}
un_vector<- 1:10
for(i in un_vector) {
 print(i*2)
}
```

### while

Este es un tipo de bucle que ocurre **mientras** una condición es verdadera (`TRUE`).
La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido.
Ejemplo:

```{r}
umbral <- 3
valor <- 0

while(valor < umbral) {
  print("Aún no llegas al umbral")
  valor <- valor + 1
}
```

Para revisar las demás estructuras, podemos revisar la referencia citada[^2]

[^2]: <https://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html>
